<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>services/component_manager.js - SNJS Documentation</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountSyncOperation.html">AccountSyncOperation</a></li><li><a href="AccountSyncResponseResolver.html">AccountSyncResponseResolver</a></li><li><a href="DeviceInterface.html">DeviceInterface</a></li><li><a href="HistorySession.html">HistorySession</a></li><li><a href="ItemsKeyManager.html">ItemsKeyManager</a><ul class='methods'><li data-type='method'><a href="ItemsKeyManager.html#addItemsKeyChangeObserver">addItemsKeyChangeObserver</a></li><li data-type='method'><a href="ItemsKeyManager.html#createNewDefaultItemsKey">createNewDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#defaultItemsKeyForItemVersion">defaultItemsKeyForItemVersion</a></li><li data-type='method'><a href="ItemsKeyManager.html#getDefaultItemsKey">getDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#handleDownloadFirstSyncCompletion">handleDownloadFirstSyncCompletion</a></li><li data-type='method'><a href="ItemsKeyManager.html#reencryptItemsKeys">reencryptItemsKeys</a></li><li data-type='method'><a href="ItemsKeyManager.html#setKeyManager">setKeyManager</a></li></ul></li><li><a href="OfflineSyncOperation_OfflineSyncOperation.html">OfflineSyncOperation</a></li><li><a href="PayloadCollection.html">PayloadCollection</a></li><li><a href="PayloadCollectionSet_PayloadCollectionSet.html">PayloadCollectionSet</a></li><li><a href="PayloadsDelta.html">PayloadsDelta</a></li><li><a href="PurePayload.html">PurePayload</a></li><li><a href="SFItem.html">SFItem</a><ul class='methods'><li data-type='method'><a href="SFItem.html#appDatacontentKeysToIgnoreWhenCheckingEquality">appDatacontentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SFItem.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SFItem.html#contentKeysToIgnoreWhenCheckingEquality">contentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SFItem.html#createdAtString">createdAtString</a></li><li data-type='method'><a href="SFItem.html#initUUID">initUUID</a></li><li data-type='method'><a href="SFItem.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SFItem.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SFItem.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SFItem.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNActionsService.html">SNActionsService</a><ul class='methods'><li data-type='method'><a href="SNActionsService.html#loadExtensionInContextOfItem">loadExtensionInContextOfItem</a></li></ul></li><li><a href="SNAlertService.html">SNAlertService</a></li><li><a href="SNApplication.html">SNApplication</a><ul class='methods'><li data-type='method'><a href="SNApplication.html#addEventObserver">addEventObserver</a></li><li data-type='method'><a href="SNApplication.html#addSingleEventObserver">addSingleEventObserver</a></li><li data-type='method'><a href="SNApplication.html#changeDeviceInterface">changeDeviceInterface</a></li><li data-type='method'><a href="SNApplication.html#changePasscode">changePasscode</a></li><li data-type='method'><a href="SNApplication.html#changePassword">changePassword</a></li><li data-type='method'><a href="SNApplication.html#clearDatabase">clearDatabase</a></li><li data-type='method'><a href="SNApplication.html#createItem">createItem</a></li><li data-type='method'><a href="SNApplication.html#deinit">deinit</a></li><li data-type='method'><a href="SNApplication.html#deleteItem">deleteItem</a></li><li data-type='method'><a href="SNApplication.html#deleteItemLocally">deleteItemLocally</a></li><li data-type='method'><a href="SNApplication.html#emptyTrash">emptyTrash</a></li><li data-type='method'><a href="SNApplication.html#findItem">findItem</a></li><li data-type='method'><a href="SNApplication.html#findItems">findItems</a></li><li data-type='method'><a href="SNApplication.html#findOrCreateTag">findOrCreateTag</a></li><li data-type='method'><a href="SNApplication.html#findTag">findTag</a></li><li data-type='method'><a href="SNApplication.html#generateUuid">generateUuid</a></li><li data-type='method'><a href="SNApplication.html#getDisplayableItems">getDisplayableItems</a></li><li data-type='method'><a href="SNApplication.html#getHost">getHost</a></li><li data-type='method'><a href="SNApplication.html#getItems">getItems</a></li><li data-type='method'><a href="SNApplication.html#getNoteCount">getNoteCount</a></li><li data-type='method'><a href="SNApplication.html#getNotesMatchingSmartTag">getNotesMatchingSmartTag</a></li><li data-type='method'><a href="SNApplication.html#getSmartTags">getSmartTags</a></li><li data-type='method'><a href="SNApplication.html#getSyncStatus">getSyncStatus</a></li><li data-type='method'><a href="SNApplication.html#getTrashedItems">getTrashedItems</a></li><li data-type='method'><a href="SNApplication.html#getUser">getUser</a></li><li data-type='method'><a href="SNApplication.html#getUserVersion">getUserVersion</a></li><li data-type='method'><a href="SNApplication.html#getValue">getValue</a></li><li data-type='method'><a href="SNApplication.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNApplication.html#importData">importData</a></li><li data-type='method'><a href="SNApplication.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNApplication.html#isEphemeralSession">isEphemeralSession</a></li><li data-type='method'><a href="SNApplication.html#isLocked">isLocked</a></li><li data-type='method'><a href="SNApplication.html#isStarted">isStarted</a></li><li data-type='method'><a href="SNApplication.html#launch">launch</a></li><li data-type='method'><a href="SNApplication.html#lock">lock</a></li><li data-type='method'><a href="SNApplication.html#mergeItem">mergeItem</a></li><li data-type='method'><a href="SNApplication.html#noAccount">noAccount</a></li><li data-type='method'><a href="SNApplication.html#prepareForLaunch">prepareForLaunch</a></li><li data-type='method'><a href="SNApplication.html#register">register</a></li><li data-type='method'><a href="SNApplication.html#registerService">registerService</a></li><li data-type='method'><a href="SNApplication.html#removePasscode">removePasscode</a></li><li data-type='method'><a href="SNApplication.html#removeValue">removeValue</a></li><li data-type='method'><a href="SNApplication.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNApplication.html#restart">restart</a></li><li data-type='method'><a href="SNApplication.html#saveItem">saveItem</a></li><li data-type='method'><a href="SNApplication.html#saveItems">saveItems</a></li><li data-type='method'><a href="SNApplication.html#savePayload">savePayload</a></li><li data-type='method'><a href="SNApplication.html#setHost">setHost</a></li><li data-type='method'><a href="SNApplication.html#setItemNeedsSync">setItemNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setItemsNeedsSync">setItemsNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setPasscode">setPasscode</a></li><li data-type='method'><a href="SNApplication.html#setStorageEncryptionPolicy">setStorageEncryptionPolicy</a></li><li data-type='method'><a href="SNApplication.html#setValue">setValue</a></li><li data-type='method'><a href="SNApplication.html#signIn">signIn</a></li><li data-type='method'><a href="SNApplication.html#signOut">signOut</a></li><li data-type='method'><a href="SNApplication.html#streamItems">streamItems</a></li><li data-type='method'><a href="SNApplication.html#sync">sync</a></li><li data-type='method'><a href="SNApplication.html#validateAccountPassword">validateAccountPassword</a></li></ul></li><li><a href="SNComponentManager.html">SNComponentManager</a><ul class='methods'><li data-type='method'><a href="SNComponentManager.html#deinit">deinit</a></li><li data-type='method'><a href="SNComponentManager.html#registerComponentWindow">registerComponentWindow</a></li></ul></li><li><a href="SNEditor.html">SNEditor</a></li><li><a href="SNHistoryManager.html">SNHistoryManager</a></li><li><a href="SNHttpService.html">SNHttpService</a></li><li><a href="SNKeyManager.html">SNKeyManager</a><ul class='methods'><li data-type='method'><a href="SNKeyManager.html#clearLocalKeyState">clearLocalKeyState</a></li><li data-type='method'><a href="SNKeyManager.html#contentTypeUsesRootKeyEncryption">contentTypeUsesRootKeyEncryption</a></li><li data-type='method'><a href="SNKeyManager.html#getAccountKeyParams">getAccountKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKey">getRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyParams">getRootKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyWrapperKeyParams">getRootKeyWrapperKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNKeyManager.html#hasRootKeyWrapper">hasRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForDecryptionOfPayload">keyToUseForDecryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForEncryptionOfPayload">keyToUseForEncryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="SNKeyManager.html#removeRootKeyWrapper">removeRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#rootKeyNeedsUnwrapping">rootKeyNeedsUnwrapping</a></li><li data-type='method'><a href="SNKeyManager.html#setDeviceInterface">setDeviceInterface</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKey">setNewRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKeyWrapper">setNewRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#unwrapRootKey">unwrapRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#validateAccountPassword">validateAccountPassword</a></li><li data-type='method'><a href="SNKeyManager.html#validatePasscode">validatePasscode</a></li><li data-type='method'><a href="SNKeyManager.html#validateWrappingKey">validateWrappingKey</a></li></ul></li><li><a href="SNMaxItemPayload.html">SNMaxItemPayload</a></li><li><a href="SNMigrationService.html">SNMigrationService</a><ul class='methods'><li data-type='method'><a href="SNMigrationService.html#handleApplicationStage">handleApplicationStage</a></li></ul></li><li><a href="SNModelManager.html">SNModelManager</a><ul class='methods'><li data-type='method'><a href="SNModelManager.html#addItem">addItem</a></li><li data-type='method'><a href="SNModelManager.html#createItem">createItem</a></li><li data-type='method'><a href="SNModelManager.html#getMasterCollection">getMasterCollection</a></li><li data-type='method'><a href="SNModelManager.html#insertItem">insertItem</a></li><li data-type='method'><a href="SNModelManager.html#insertItems">insertItems</a></li><li data-type='method'><a href="SNModelManager.html#setItemDirty">setItemDirty</a></li><li data-type='method'><a href="SNModelManager.html#setItemProperties">setItemProperties</a></li></ul></li><li><a href="SNNote.html">SNNote</a><ul class='methods'><li data-type='method'><a href="SNNote.html#appDatacontentKeysToIgnoreWhenCheckingEquality">appDatacontentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SNNote.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SNNote.html#contentKeysToIgnoreWhenCheckingEquality">contentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SNNote.html#createdAtString">createdAtString</a></li><li data-type='method'><a href="SNNote.html#initUUID">initUUID</a></li><li data-type='method'><a href="SNNote.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SNNote.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SNNote.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SNNote.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNNoteSFItem.html">SFItem</a></li><li><a href="SNNoteSNNoteSFItem.html">SFItem</a></li><li><a href="SNPrivilegesService.html">SNPrivilegesService</a><ul class='methods'><li data-type='method'><a href="SNPrivilegesService.html#actionRequiresPrivilege">actionRequiresPrivilege</a></li><li data-type='method'><a href="SNPrivilegesService.html#netCredentialsForAction">netCredentialsForAction</a></li></ul></li><li><a href="SNProtocolOperator.html">SNProtocolOperator</a><ul class='methods'><li data-type='method'><a href="SNProtocolOperator.html#createItemsKey">createItemsKey</a></li><li data-type='method'><a href="SNProtocolOperator.html#generateNewItemsKeyContent">generateNewItemsKeyContent</a></li></ul></li><li><a href="SNProtocolService.html">SNProtocolService</a><ul class='methods'><li data-type='method'><a href="SNProtocolService.html#compareRootKeys">compareRootKeys</a></li><li data-type='method'><a href="SNProtocolService.html#createBackupFile">createBackupFile</a></li><li data-type='method'><a href="SNProtocolService.html#decryptErroredItems">decryptErroredItems</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByDecryptingPayload">payloadByDecryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByEncryptingPayload">payloadByEncryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#setKeyManager">setKeyManager</a></li><li data-type='method'><a href="SNProtocolService.html#supportedVersions">supportedVersions</a></li></ul></li><li><a href="SNRootKey.html">SNRootKey</a><ul class='methods'><li data-type='method'><a href="SNRootKey.html#compare">compare</a></li><li data-type='method'><a href="SNRootKey.html#getPersistableValue">getPersistableValue</a></li></ul></li><li><a href="SNRootKeyParams.html">SNRootKeyParams</a><ul class='methods'><li data-type='method'><a href="SNRootKeyParams.html#getPortableValue">getPortableValue</a></li></ul></li><li><a href="SNSavedServerItemPayload.html">SNSavedServerItemPayload</a></li><li><a href="SNSessionManager.html">SNSessionManager</a></li><li><a href="SNSingletonManager.html">SNSingletonManager</a><ul class='methods'><li data-type='method'><a href="SNSingletonManager.html#addObservers">addObservers</a></li><li data-type='method'><a href="SNSingletonManager.html#registerPredicate">registerPredicate</a></li></ul></li><li><a href="SNStorageService.html">SNStorageService</a><ul class='methods'><li data-type='method'><a href="SNStorageService.html#canDecryptWithKey">canDecryptWithKey</a></li><li data-type='method'><a href="SNStorageService.html#clearValues">clearValues</a></li><li data-type='method'><a href="SNStorageService.html#decryptStorage">decryptStorage</a></li><li data-type='method'><a href="SNStorageService.html#generatePersistenceValue">generatePersistenceValue</a></li><li data-type='method'><a href="SNStorageService.html#getAllRawPayloads">getAllRawPayloads</a></li><li data-type='method'><a href="SNStorageService.html#getPersistenceKey">getPersistenceKey</a></li><li data-type='method'><a href="SNStorageService.html#handleApplicationStage">handleApplicationStage</a></li><li data-type='method'><a href="SNStorageService.html#isStorageWrapped">isStorageWrapped</a></li><li data-type='method'><a href="SNStorageService.html#setInitialValues">setInitialValues</a></li></ul></li><li><a href="SNSyncService.html">SNSyncService</a><ul class='methods'><li data-type='method'><a href="SNSyncService.html#computeDataIntegrityHash">computeDataIntegrityHash</a></li><li data-type='method'><a href="SNSyncService.html#getDatabasePayloads">getDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#handleNeverSyncedDeleted">handleNeverSyncedDeleted</a></li><li data-type='method'><a href="SNSyncService.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNSyncService.html#loadDatabasePayloads">loadDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#markAllItemsAsNeedingSync">markAllItemsAsNeedingSync</a></li><li data-type='method'><a href="SNSyncService.html#payloadsByPreparingForServer">payloadsByPreparingForServer</a></li><li data-type='method'><a href="SNSyncService.html#popPayloadsNeedingPreSyncSave">popPayloadsNeedingPreSyncSave</a></li><li data-type='method'><a href="SNSyncService.html#popSpawnQueue">popSpawnQueue</a></li><li data-type='method'><a href="SNSyncService.html#repersistAllItems">repersistAllItems</a></li><li data-type='method'><a href="SNSyncService.html#resetSyncState">resetSyncState</a></li><li data-type='method'><a href="SNSyncService.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNSyncService.html#sync">sync</a></li><li data-type='method'><a href="SNSyncService.html#ut_beginLatencySimulator">ut_beginLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_endLatencySimulator">ut_endLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_setDatabaseLoaded">ut_setDatabaseLoaded</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayByDifference">arrayByDifference</a></li><li><a href="global.html#arrayByRemovingFromIndex">arrayByRemovingFromIndex</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#deepMerge">deepMerge</a></li><li><a href="global.html#DEFAULT_AUTO_SYNC_INTERVAL">DEFAULT_AUTO_SYNC_INTERVAL</a></li><li><a href="global.html#DEFAULT_ITEM_REVISIONS_THRESHOLD">DEFAULT_ITEM_REVISIONS_THRESHOLD</a></li><li><a href="global.html#extendArray">extendArray</a></li><li><a href="global.html#intentRequiresEncryption">intentRequiresEncryption</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_NONE">KEY_MODE_ROOT_KEY_NONE</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_ONLY">KEY_MODE_ROOT_KEY_ONLY</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_PLUS_WRAPPER">KEY_MODE_ROOT_KEY_PLUS_WRAPPER</a></li><li><a href="global.html#KEY_MODE_WRAPPER_ONLY">KEY_MODE_WRAPPER_ONLY</a></li><li><a href="global.html#LARGE_ENTRY_DELTA_THRESHOLD">LARGE_ENTRY_DELTA_THRESHOLD</a></li><li><a href="global.html#LAST_NONROOT_ITEMS_KEY_VERSION">LAST_NONROOT_ITEMS_KEY_VERSION</a></li><li><a href="global.html#lastElement">lastElement</a></li><li><a href="global.html#omitByCopy">omitByCopy</a></li><li><a href="global.html#PayloadsByAlternatingUuid">PayloadsByAlternatingUuid</a></li><li><a href="global.html#PayloadsByDuplicating">PayloadsByDuplicating</a></li><li><a href="global.html#pickByCopy">pickByCopy</a></li><li><a href="global.html#RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP">RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#removeFromIndex">removeFromIndex</a></li><li><a href="global.html#SortPayloadsByRecentAndContentPriority">SortPayloadsByRecentAndContentPriority</a></li><li><a href="global.html#StorageEncryptionPolicies">StorageEncryptionPolicies</a></li><li><a href="global.html#StoragePersistencePolicies">StoragePersistencePolicies</a></li><li><a href="global.html#StorageValueModes">StorageValueModes</a></li><li><a href="global.html#subtractFromArray">subtractFromArray</a></li><li><a href="global.html#ValueModesKeys">ValueModesKeys</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">services/component_manager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import find from 'lodash/find';
import pull from 'lodash/pull';
import uniq from 'lodash/uniq';
import remove from 'lodash/remove';
import { PureService } from '@Lib/services/pure_service';
import {
  CreateMaxPayloadFromAnyObject,
  CreateSourcedPayloadFromObject,
  PayloadSources
} from '@Payloads';
import {
  ContentTypes, displayStringForContentType, CreateItemFromPayload
} from '@Models';
import { ComponentAreas } from '@Models/app/component';
import { Uuid } from '@Lib/uuid';
import { Copy, isString } from '@Lib/utils';
import { Platforms, Environments, platformToString, environmentToString } from '@Lib/platforms';

const DESKTOP_URL_PREFIX = 'sn://';
const LOCAL_HOST = 'localhost';
const CUSTOM_LOCAL_HOST = 'sn.local';
const ANDROID_LOCAL_HOST = '10.0.2.2';

export const ComponentActions = {
  SetSize: 'set-size',
  StreamItems: 'stream-items',
  StreamContextItem: 'stream-context-item',
  SaveItems: 'save-items',
  SelectItem: 'select-item',
  AssociateItem: 'associate-item',
  DeassociateItem: 'deassociate-item',
  ClearSelection: 'clear-selection',
  CreateItem: 'create-item',
  CreateItems: 'create-items',
  DeleteItems: 'delete-items',
  SetComponentData: 'set-component-data',
  InstallLocalComponent: 'install-local-component',
  ToggleActivateComponent: 'toggle-activate-component',
  RequestPermissions: 'request-permissions',
  PresentConflictResolution: 'present-conflict-resolution',
  DuplicateItem: 'duplicate-item',
  ComponentRegistered: 'component-registered',
  ActivateThemes: 'themes',
  Reply: 'reply'
};

/**
 * Responsible for orchestrating component functionality, including editors, themes,
 * and other components. The component manager primarily deals with iframes, and orchestrates
 * sending and receiving messages to and from frames via the postMessage API.
 */
export class SNComponentManager extends PureService {
  constructor({
    modelManager,
    syncService,
    alertService,
    timeout,
    environment,
    platform
  }) {
    super();
    /* This domain will be used to save context item client data */
    SNComponentManager.ClientDataDomain = 'org.standardnotes.sn.components';
    this.timeout = timeout || setTimeout.bind(window);
    this.modelManager = modelManager;
    this.syncService = syncService;
    this.alertService = alertService;
    this.environment = environment;
    this.platform = platform;
    this.isDesktop = this.environment === Environments.Desktop;
    this.isMobile = this.environment === Environments.Mobile;
    this.streamObservers = [];
    this.contextStreamObservers = [];
    this.activeComponents = [];
    this.permissionDialogs = [];
    this.handlers = [];

    this.configureForGeneralUsage();
    if (environment !== Environments.Mobile) {
      this.configureForNonMobileUsage();
    }
  }

  setDesktopManager(desktopManager) {
    this.desktopManager = desktopManager;
    this.configureForDesktop();
  }

  configureForGeneralUsage() {
    this.modelManager.addMappingObserver(
      '*',
      async (allItems, validItems, deletedItems, source, sourceKey) => {
        const syncedComponents = allItems.filter((item) => {
          return (
            item.content_type === ContentTypes.Component ||
            item.content_type === ContentTypes.Theme);
        });
        /**
         * We only want to sync if the item source is Retrieved, not RemoteSaved to avoid 
         * recursion caused by the component being modified and saved after it is updated.
        */
        if (syncedComponents.length > 0 &amp;&amp; source !== PayloadSources.RemoteSaved) {
          /* Ensure any component in our data is installed by the system */
          if (this.isDesktop) {
            this.desktopManager.syncComponentsInstallation(syncedComponents);
          }
        }
        for (const component of syncedComponents) {
          const activeComponent = find(this.activeComponents, { uuid: component.uuid });
          if (component.active &amp;&amp; !component.deleted &amp;&amp; !activeComponent) {
            await this.activateComponent(component);
          } else if (!component.active &amp;&amp; activeComponent) {
            await this.deactivateComponent(component);
          }
        }
        for (const observer of this.streamObservers) {
          if (sourceKey &amp;&amp; sourceKey === observer.component.uuid) {
            /* Don't notify source of change, as it is the originator, doesn't need duplicate event. */
            continue;
          }
          const relevantItems = allItems.filter((item) => {
            return observer.contentTypes.indexOf(item.content_type) !== -1;
          });
          if (relevantItems.length === 0) {
            continue;
          }
          const requiredPermissions = [{
            name: ComponentActions.StreamItems,
            content_types: observer.contentTypes.sort()
          }];
          this.runWithPermissions(observer.component, requiredPermissions, () => {
            this.sendItemsInReply(observer.component, relevantItems, observer.originalMessage);
          });
        }
        const requiredContextPermissions = [{
          name: ComponentActions.StreamContextItem
        }];
        for (const observer of this.contextStreamObservers) {
          if (sourceKey &amp;&amp; sourceKey === observer.component.uuid) {
            /* Don't notify source of change, as it is the originator, doesn't need duplicate event. */
            continue;
          }
          for (const handler of this.handlers) {
            if (!handler.areas.includes(observer.component.area) &amp;&amp; !handler.areas.includes('*')) {
              continue;
            }
            if (handler.contextRequestHandler) {
              const itemInContext = handler.contextRequestHandler(observer.component);
              if (itemInContext) {
                const matchingItem = find(allItems, { uuid: itemInContext.uuid });
                if (matchingItem) {
                  this.runWithPermissions(observer.component, requiredContextPermissions, () => {
                    this.sendContextItemInReply(
                      observer.component,
                      matchingItem,
                      observer.originalMessage,
                      source
                    );
                  });
                }
              }
            }
          }
        }
      });
  }

  isNativeExtension(component) {
    const nativeUrls = [
      window._extensions_manager_location,
      window._batch_manager_location
    ];
    const hostedUrl = component.content.hosted_url;
    const localUrl = component.content.local_url
      &amp;&amp; component.content.local_url.replace(DESKTOP_URL_PREFIX, '');
    return nativeUrls.includes(hostedUrl) || nativeUrls.includes(localUrl);
  }

  /** @override */
  async deinit() {
    super.deinit();
    if (window) {
      window.removeEventListener('focus', this.detectFocusChange, true);
      window.removeEventListener('blur', this.detectFocusChange, true);
      window.removeEventListener('message', this.onWindowMessage);
    }
  }

  detectFocusChange = () => {
    for (const component of this.activeComponents) {
      if (document.activeElement === this.iframeForComponent(component)) {
        this.timeout(() => {
          this.focusChangedForComponent(component);
        });
        break;
      }
    }
  };

  onWindowMessage = (event) => {
    this.log('Web app: received message', event);
    /** Make sure this message is for us */
    if (event.data.sessionKey) {
      this.handleMessage(
        this.componentForSessionKey(event.data.sessionKey),
        event.data
      );
    }
  }

  configureForNonMobileUsage() {
    window.addEventListener
      ? window.addEventListener('focus', this.detectFocusChange, true)
      : window.attachEvent('onfocusout', this.detectFocusChange);
    window.addEventListener
      ? window.addEventListener('blur', this.detectFocusChange, true)
      : window.attachEvent('onblur', this.detectFocusChange);

    /* On mobile, events listeners are handled by a respective component */
    window.addEventListener('message', this.onWindowMessage);
  }

  configureForDesktop() {
    this.desktopManager.registerUpdateObserver((component) => {
      /* Reload theme if active */
      if (component.active &amp;&amp; component.isTheme()) {
        this.postActiveThemesToAllComponents();
      }
    });
  }

  postActiveThemesToAllComponents() {
    for (const component of this.components) {
      /* Skip over components that are themes themselves,
        or components that are not active, or components that don't have a window */
      if (component.isTheme() || !component.active || !component.window) {
        continue;
      }
      this.postActiveThemesToComponent(component);
    }
  }

  getActiveThemes() {
    return this.componentsForArea(ComponentAreas.Themes).filter((theme) => {
      return theme.active;
    });
  }

  urlsForActiveThemes() {
    const themes = this.getActiveThemes();
    return themes.map((theme) => {
      return this.urlForComponent(theme);
    });
  }

  postActiveThemesToComponent(component) {
    const urls = this.urlsForActiveThemes();
    const data = { themes: urls };
    this.sendMessageToComponent(component, {
      action: ComponentActions.ActivateThemes, data: data
    });
  }

  contextItemDidChangeInArea(area) {
    for (const handler of this.handlers) {
      if (handler.areas.includes(area) === false &amp;&amp; !handler.areas.includes('*')) {
        continue;
      }
      const observers = this.contextStreamObservers.filter((observer) => {
        return observer.component.area === area;
      });
      for (const observer of observers) {
        if (handler.contextRequestHandler) {
          const itemInContext = handler.contextRequestHandler(observer.component);
          if (itemInContext) {
            this.sendContextItemInReply(
              observer.component,
              itemInContext,
              observer.originalMessage
            );
          }
        }
      }
    }
  }

  setComponentHidden(component, hidden) {
    /** 
     * A hidden component will not receive messages. However, when a component is unhidden, 
     * we need to send it any items it may have registered streaming for.
     */
    if (hidden) {
      component.hidden = true;
    } else if (component.hidden) {
      component.hidden = false;
      const contextObserver = find(this.contextStreamObservers, { identifier: component.uuid });
      if (contextObserver) {
        this.handleStreamContextItemMessage(component, contextObserver.originalMessage);
      }
      const streamObserver = find(this.streamObservers, { identifier: component.uuid });
      if (streamObserver) {
        this.handleStreamItemsMessage(component, streamObserver.originalMessage);
      }
    }
  }

  jsonForItem(item, component, source) {
    const params = {
      uuid: item.uuid,
      content_type: item.content_type,
      created_at: item.created_at,
      updated_at: item.updated_at,
      deleted: item.deleted
    };
    params.content = item.collapseContent();
    params.clientData = item.getDomainDataItem(
      component.getClientDataKey(),
      SNComponentManager.ClientDataDomain
    ) || {};
    /** 
     * isMetadataUpdate implies that the extension should make reference of updated 
     * metadata, but not update content values as they may be stale relative to what the 
     * extension currently has Changes are always metadata updates if the mapping source 
     * is PayloadSources.RemoteSaved || source === PayloadSources.LocalSaved.
    */
    if (source &amp;&amp; (source === PayloadSources.RemoteSaved || source === PayloadSources.LocalSaved)) {
      params.isMetadataUpdate = true;
    }
    this.removePrivatePropertiesFromResponseItems([params], component);
    return params;
  }

  sendItemsInReply(component, items, message, source) {
    this.log('Web|componentManager|sendItemsInReply', component, items, message);
    const response = { items: {} };
    const mapped = items.map((item) => {
      return this.jsonForItem(item, component, source);
    });
    response.items = mapped;
    this.replyToMessage(component, message, response);
  }

  sendContextItemInReply(component, item, originalMessage, source) {
    this.log('Web|componentManager|sendContextItemInReply', component, item, originalMessage);
    const response = { item: this.jsonForItem(item, component, source) };
    this.replyToMessage(component, originalMessage, response);
  }

  replyToMessage(component, originalMessage, replyData) {
    const reply = {
      action: ComponentActions.Reply,
      original: originalMessage,
      data: replyData
    };
    this.sendMessageToComponent(component, reply);
  }

  sendMessageToComponent(component, message) {
    const permissibleActionsWhileHidden = [
      ComponentActions.ComponentRegistered,
      ComponentActions.ActivateThemes
    ];
    if (component.hidden &amp;&amp; !permissibleActionsWhileHidden.includes(message.action)) {
      this.log('Component disabled for current item, ignoring messages.', component.name);
      return;
    }
    this.log('Web|sendMessageToComponent', component, message);
    let origin = this.urlForComponent(component);
    if (!origin.startsWith('http') &amp;&amp; !origin.startsWith('file')) {
      /* Native extension running in web, prefix current host */
      origin = window.location.href + origin;
    }
    if (!component.window) {
      this.alertService.alert({
        text: `Standard Notes is trying to communicate with ${component.name}, 
        but an error is occurring. Please restart this extension and try again.`
      });
    }
    /* Mobile messaging requires json */
    if (this.isMobile) {
      message = JSON.stringify(message);
    }
    component.window.postMessage(message, origin);
  }

  get components() {
    return this.modelManager.getItems([
      ContentTypes.Component,
      ContentTypes.Theme
    ]);
  }

  componentsForArea(area) {
    return this.components.filter((component) => {
      return component.area === area;
    });
  }

  urlForComponent(component) {
    /* offlineOnly is available only on desktop, and not on web or mobile. */
    if (component.offlineOnly &amp;&amp; !this.isDesktop) {
      return null;
    }
    if (component.offlineOnly || (this.isDesktop &amp;&amp; component.local_url)) {
      return component.local_url
        &amp;&amp; component.local_url.replace(
          DESKTOP_URL_PREFIX,
          this.desktopManager.getExtServerHost()
        );
    } else {
      let url = component.hosted_url || component.legacy_url;
      if (this.isMobile) {
        const localReplacement = this.platform === Platforms.Ios ? LOCAL_HOST : ANDROID_LOCAL_HOST;
        url = url.replace(LOCAL_HOST, localReplacement).replace(CUSTOM_LOCAL_HOST, localReplacement);
      }
      return url;
    }
  }

  componentForUrl(url) {
    return this.components.filter((component) => {
      return component.hosted_url === url || component.legacy_url === url;
    })[0];
  }

  componentForSessionKey(key) {
    let component = find(this.components, { sessionKey: key });
    if (!component) {
      for (const handler of this.handlers) {
        if (handler.componentForSessionKeyHandler) {
          component = handler.componentForSessionKeyHandler(key);
          if (component) {
            break;
          }
        }
      }
    }
    return component;
  }

  handleMessage(component, message) {
    if (!component) {
      this.log('Component not defined for message, returning', message);
      this.alertService.alert({
        text: 'An extension is trying to communicate with Standard Notes,' +
          'but there is an error establishing a bridge. Please restart the app and try again.'
      });
      return;
    }
    const readwriteActions = [
      ComponentActions.SaveItems,
      ComponentActions.AssociateItem,
      ComponentActions.DeassociateItem,
      ComponentActions.CreateItem,
      ComponentActions.CreateItems,
      ComponentActions.DeleteItems,
      ComponentActions.SetComponentData
    ];
    if (component.readonly &amp;&amp; readwriteActions.includes(message.action)) {
      this.alertService.alert({
        text: `The extension ${component.name} is trying to save, but it is in a locked state and cannot accept changes.`
      });
      return;
    }
    if (message.action === ComponentActions.StreamItems) {
      this.handleStreamItemsMessage(component, message);
    } else if (message.action === ComponentActions.StreamContextItem) {
      this.handleStreamContextItemMessage(component, message);
    } else if (message.action === ComponentActions.SetComponentData) {
      this.handleSetComponentDataMessage(component, message);
    } else if (message.action === ComponentActions.DeleteItems) {
      this.handleDeleteItemsMessage(component, message);
    } else if (message.action === ComponentActions.CreateItems || message.action === ComponentActions.CreateItem) {
      this.handleCreateItemsMessage(component, message);
    } else if (message.action === ComponentActions.SaveItems) {
      this.handleSaveItemsMessage(component, message);
    } else if (message.action === ComponentActions.ToggleActivateComponent) {
      const componentToToggle = this.modelManager.findItem(message.data.uuid);
      this.handleToggleComponentMessage(component, componentToToggle, message);
    } else if (message.action === ComponentActions.RequestPermissions) {
      this.handleRequestPermissionsMessage(component, message);
    } else if (message.action === ComponentActions.InstallLocalComponent) {
      this.handleInstallLocalComponentMessage(component, message);
    } else if (message.action === ComponentActions.DuplicateItem) {
      this.handleDuplicateItemMessage(component, message);
    }
    for (const handler of this.handlers) {
      if (handler.actionHandler &amp;&amp; (handler.areas.includes(component.area) || handler.areas.includes('*'))) {
        this.timeout(() => {
          handler.actionHandler(component, message.action, message.data);
        });
      }
    }
  }

  removePrivatePropertiesFromResponseItems(responseItems, component, options = {}) {
    /* We want to remove updated_at if incoming, but keep otherwise */
    if (options.incoming) {
      /* Maintaining our own updated_at value is imperative for sync to work properly, 
        we ignore any incoming value. */
      const privateTopLevelProperties = ['updated_at'];
      for (const responseItem of responseItems) {
        if (responseItem.isItem) {
          console.error('Attempting to pass object. Use JSON.');
          continue;
        }
        for (const privateProperty of privateTopLevelProperties) {
          delete responseItem[privateProperty];
        }
      }
    }
    if (component) {
      /* System extensions can bypass this step */
      if (this.isNativeExtension(component)) {
        return;
      }
    }
    /* Don't allow component to overwrite these properties. */
    let privateContentProperties = ['autoupdateDisabled', 'permissions', 'active'];
    if (options) {
      if (options.includeUrls) {
        privateContentProperties = privateContentProperties.concat(['url', 'hosted_url', 'local_url']);
      }
    }
    for (const responseItem of responseItems) {
      /* Do not pass in actual items here, otherwise that would be destructive.
         Instead, generic JS/JSON objects should be passed. */
      if (responseItem.isItem) {
        console.error('Attempting to pass object. Use JSON.');
        continue;
      }
      for (const prop of privateContentProperties) {
        delete responseItem.content[prop];
      }
    }
  }

  handleStreamItemsMessage(component, message) {
    const requiredPermissions = [
      {
        name: ComponentActions.StreamItems,
        content_types: message.data.content_types.sort()
      }
    ];
    this.runWithPermissions(component, requiredPermissions, () => {
      if (!find(this.streamObservers, { identifier: component.uuid })) {
        /* For pushing laster as changes come in */
        this.streamObservers.push({
          identifier: component.uuid,
          component: component,
          originalMessage: message,
          contentTypes: message.data.content_types
        });
      }
      /* Push immediately now */
      let items = [];
      for (const contentType of message.data.content_types) {
        items = items.concat(this.modelManager.validItemsForContentType(contentType));
      }
      this.sendItemsInReply(component, items, message);
    });
  }

  handleStreamContextItemMessage(component, message) {
    const requiredPermissions = [
      {
        name: ComponentActions.StreamContextItem
      }
    ];
    this.runWithPermissions(component, requiredPermissions, () => {
      if (!find(this.contextStreamObservers, { identifier: component.uuid })) {
        this.contextStreamObservers.push({
          identifier: component.uuid,
          component: component,
          originalMessage: message
        });
      }
      for (const handler of this.handlersForArea(component.area)) {
        if (handler.contextRequestHandler) {
          const itemInContext = handler.contextRequestHandler(component);
          if (itemInContext) {
            this.sendContextItemInReply(component, itemInContext, message);
          }
        }
      }
    });
  }

  isItemIdWithinComponentContextJurisdiction(uuid, component) {
    const itemIdsInJurisdiction = this.itemIdsInContextJurisdictionForComponent(component);
    return itemIdsInJurisdiction.includes(uuid);
  }

  /* Returns items that given component has context permissions for */
  itemIdsInContextJurisdictionForComponent(component) {
    const itemIds = [];
    for (const handler of this.handlersForArea(component.area)) {
      if (handler.contextRequestHandler) {
        const itemInContext = handler.contextRequestHandler(component);
        if (itemInContext) {
          itemIds.push(itemInContext.uuid);
        }
      }
    }
    return itemIds;
  }

  handlersForArea(area) {
    return this.handlers.filter((candidate) => {
      return candidate.areas.includes(area);
    });
  }

  async handleSaveItemsMessage(component, message) {
    const responseItems = message.data.items;
    const requiredPermissions = [];
    const itemIdsInContextJurisdiction = this.itemIdsInContextJurisdictionForComponent(component);
    /* Pending as in needed to be accounted for in permissions. */
    const pendingResponseItems = responseItems.slice();
    for (const responseItem of responseItems.slice()) {
      if (itemIdsInContextJurisdiction.includes(responseItem.uuid)) {
        requiredPermissions.push({
          name: ComponentActions.StreamContextItem
        });
        pull(pendingResponseItems, responseItem);
        /* We break because there can only be one context item */
        break;
      }
    }
    /* Check to see if additional privileges are required */
    if (pendingResponseItems.length > 0) {
      const requiredContentTypes = uniq(pendingResponseItems.map((i) => {
        return i.content_type;
      })).sort();
      requiredPermissions.push({
        name: ComponentActions.StreamItems,
        content_types: requiredContentTypes
      });
    }
    this.runWithPermissions(component, requiredPermissions, async () => {
      this.removePrivatePropertiesFromResponseItems(
        responseItems,
        component,
        { includeUrls: true, incoming: true }
      );

      /* Filter locked items */
      const ids = responseItems.map((i) => { return i.uuid; });
      const items = this.modelManager.findItems(ids);
      let lockedCount = 0;
      for (const item of items) {
        if (item.locked) {
          remove(responseItems, { uuid: item.uuid });
          lockedCount++;
        }
      }
      if (lockedCount > 0) {
        const itemNoun = lockedCount === 1 ? 'item' : 'items';
        const auxVerb = lockedCount === 1 ? 'is' : 'are';
        this.alertService.alert({
          title: 'Items Locked',
          text: `${lockedCount} ${itemNoun} you are attempting to save ${auxVerb} locked and cannot be edited.`
        });
      }
      const payloads = responseItems.map((responseItem) => {
        return CreateMaxPayloadFromAnyObject({ object: responseItem });
      });
      const localItems = await this.modelManager.mapPayloadsToLocalItems({
        paylods: payloads,
        source: PayloadSources.ComponentRetrieved,
        sourceKey: component.uuid
      });
      for (const responseItem of responseItems) {
        const item = find(localItems, { uuid: responseItem.uuid });
        if (!item) {
          // An item this extension is trying to save was possibly removed locally, notify user
          this.alertService.alert({
            text: `The extension ${component.name} is trying to save an item with type` +
              `${responseItem.content_type}, but that item does not exist. Please restart this extension and try again.`
          });
          continue;
        }
        if (!item.locked) {
          if (responseItem.clientData) {
            item.setDomainDataItem(
              component.getClientDataKey(),
              responseItem.clientData,
              SNComponentManager.ClientDataDomain
            );
          }
          await this.modelManager.setItemDirty(
            item,
            true,
            true,
            PayloadSources.ComponentRetrieved,
            component.uuid
          );
        }
      }
      this.syncService.sync().then((response) => {
        /* Allow handlers to be notified when a save begins and ends, to update the UI */
        const saveMessage = Object.assign({}, message);
        saveMessage.action = response &amp;&amp; response.error ? 'save-error' : 'save-success';
        this.replyToMessage(component, message, { error: response &amp;&amp; response.error });
        this.handleMessage(component, saveMessage);
      });
    });
  }

  handleDuplicateItemMessage(component, message) {
    const itemParams = message.data.item;
    const item = this.modelManager.findItem(itemParams.uuid);
    const requiredPermissions = [
      {
        name: ComponentActions.StreamItems,
        content_types: [item.content_type]
      }
    ];
    this.runWithPermissions(component, requiredPermissions, async () => {
      const duplicate = await this.modelManager.duplicateItem({ item });
      this.syncService.sync();
      this.replyToMessage(component, message, { item: this.jsonForItem(duplicate, component) });
    });
  }

  handleCreateItemsMessage(component, message) {
    const responseItems = message.data.item ? [message.data.item] : message.data.items;
    const uniqueContentTypes = uniq(responseItems.map((item) => { return item.content_type; }));
    const requiredPermissions = [
      {
        name: ComponentActions.StreamItems,
        content_types: uniqueContentTypes
      }
    ];
    this.runWithPermissions(component, requiredPermissions, async () => {
      this.removePrivatePropertiesFromResponseItems(responseItems, component, { incoming: true });
      const processedItems = [];
      for (const responseItem of responseItems) {
        const payload = CreateSourcedPayloadFromObject({
          object: responseItem,
          source: PayloadSources.RemoteRetrieved
        });
        const item = CreateItemFromPayload(payload);
        if (responseItem.clientData) {
          item.setDomainDataItem(
            component.getClientDataKey(),
            responseItem.clientData,
            SNComponentManager.ClientDataDomain
          );
        }
        this.modelManager.addItem(item);
        await this.modelManager.resolveReferencesForItem(item, true);
        await this.modelManager.setItemDirty(item, true);
        processedItems.push(item);
      }
      this.syncService.sync();
      const reply = message.action === ComponentActions.CreateItem
        ? { item: this.jsonForItem(processedItems[0], component) }
        : { items: processedItems.map((item) => { return this.jsonForItem(item, component); }) };
      this.replyToMessage(component, message, reply);
    });
  }

  handleDeleteItemsMessage(component, message) {
    const requiredContentTypes = uniq(message.data.items.map((i) => { return i.content_type; })).sort();
    const requiredPermissions = [
      {
        name: ComponentActions.StreamItems,
        content_types: requiredContentTypes
      }
    ];
    this.runWithPermissions(component, requiredPermissions, async () => {
      const itemsData = message.data.items;
      const noun = itemsData.length === 1 ? 'item' : 'items';
      let reply = null;
      let didConfirm = true;
      await this.alertService.confirm({ text: `Are you sure you want to delete ${itemsData.length} ${noun}?` })
        .catch(() => {
          didConfirm = false;
        });
      if (didConfirm) {
        /* Filter for any components and deactivate before deleting */
        for (const itemData of itemsData) {
          const model = this.modelManager.findItem(itemData.uuid);
          if (!model) {
            this.alertService.alert({ text: 'The item you are trying to delete cannot be found.' });
            continue;
          }
          if ([ContentTypes.Component, ContentTypes.Theme].includes(model.content_type)) {
            await this.deactivateComponent(model, true);
          }
          await this.modelManager.setItemToBeDeleted(model);
          /* Currently extensions are not notified of association until a full server sync completes.
             We manually notify observers. */
          this.modelManager.notifyMappingObservers([model], PayloadSources.RemoteSaved);
        }
        this.syncService.sync();
        reply = { deleted: true };
      } else {
        /* Rejected by user */
        reply = { deleted: false };
      }
      this.replyToMessage(component, message, reply);
    });
  }

  handleRequestPermissionsMessage(component, message) {
    this.runWithPermissions(component, message.data.permissions, () => {
      this.replyToMessage(component, message, { approved: true });
    });
  }

  handleSetComponentDataMessage(component, message) {
    /* A component setting its own data does not require special permissions */
    this.runWithPermissions(component, [], async () => {
      component.componentData = message.data.componentData;
      await this.modelManager.setItemDirty(component, true);
      this.syncService.sync();
    });
  }

  handleToggleComponentMessage(sourceComponent, targetComponent, message) {
    this.toggleComponent(targetComponent);
  }

  async toggleComponent(component) {
    if (component.area === ComponentAreas.Modal) {
      this.openModalComponent(component);
    } else {
      if (component.active) {
        await this.deactivateComponent(component);
      } else {
        if (component.content_type === ContentTypes.Theme) {
          /* Deactive currently active theme if new theme is not layerable */
          const activeThemes = this.getActiveThemes();
          /* Activate current before deactivating others, so as not to flicker */
          await this.activateComponent(component);
          if (!component.isLayerable()) {
            setTimeout(async () => {
              for (const theme of activeThemes) {
                if (theme &amp;&amp; !theme.isLayerable()) {
                  await this.deactivateComponent(theme);
                }
              }
            }, 10);
          }
        } else {
          await this.activateComponent(component);
        }
      }
    }
  }

  handleInstallLocalComponentMessage(sourceComponent, message) {
    /* Only native extensions have this permission */
    if (!this.isNativeExtension(sourceComponent)) {
      return;
    }
    const targetComponent = this.modelManager.findItem(message.data.uuid);
    this.desktopManager.installComponent(targetComponent);
  }

  runWithPermissions(component, requiredPermissions, runFunction) {
    if (!component.permissions) {
      component.permissions = [];
    }
    /* Make copy as not to mutate input values */
    requiredPermissions = Copy(requiredPermissions);
    const acquiredPermissions = component.permissions;
    for (const required of requiredPermissions.slice()) {
      /* Remove anything we already have */
      const respectiveAcquired = acquiredPermissions.find((candidate) => candidate.name === required.name);
      if (!respectiveAcquired) {
        continue;
      }
      /* We now match on name, lets substract from required.content_types anything we have in acquired. */
      const requiredContentTypes = required.content_types;
      if (!requiredContentTypes) {
        /* If this permission does not require any content types (i.e stream-context-item)
          then we can remove this from required since we match by name (respectiveAcquired.name === required.name) */
        pull(requiredPermissions, required);
        continue;
      }
      for (const acquiredContentType of respectiveAcquired.content_types) {
        pull(requiredContentTypes, acquiredContentType);
      }
      if (requiredContentTypes.length === 0) {
        /* We've removed all acquired and end up with zero, means we already have all these permissions */
        pull(requiredPermissions, required);
      }
    }
    if (requiredPermissions.length > 0) {
      this.promptForPermissions(component, requiredPermissions, (approved) => {
        if (approved) {
          runFunction();
        }
      });
    } else {
      runFunction();
    }
  }

  promptForPermissions(component, permissions, callback) {
    const params = {};
    params.component = component;
    params.permissions = permissions;
    params.permissionsString = this.permissionsStringForPermissions(permissions, component);
    params.actionBlock = callback;
    params.callback = async (approved) => {
      if (approved) {
        for (const permission of permissions) {
          const matchingPermission = component.permissions.find((candidate) => candidate.name === permission.name);
          if (!matchingPermission) {
            component.permissions.push(permission);
          } else {
            /* Permission already exists, but content_types may have been expanded */
            const contentTypes = matchingPermission.content_types || [];
            matchingPermission.content_types = uniq(contentTypes.concat(permission.content_types));
          }
        }
        await this.modelManager.setItemDirty(component, true);
        this.syncService.sync();
      }
      this.permissionDialogs = this.permissionDialogs.filter((pendingDialog) => {
        /* Remove self */
        if (pendingDialog === params) {
          pendingDialog.actionBlock &amp;&amp; pendingDialog.actionBlock(approved);
          return false;
        }
        const containsObjectSubset = function (source, target) {
          return !target.some(val => !source.find((candidate) => JSON.stringify(candidate) === JSON.stringify(val)));
        };
        if (pendingDialog.component === component) {
          /* remove pending dialogs that are encapsulated by already approved permissions, and run its function */
          if (pendingDialog.permissions === permissions || containsObjectSubset(permissions, pendingDialog.permissions)) {
            /* If approved, run the action block. Otherwise, if canceled, cancel any 
            pending ones as well, since the user was explicit in their intentions */
            if (approved) {
              pendingDialog.actionBlock &amp;&amp; pendingDialog.actionBlock(approved);
            }
            return false;
          }
        }
        return true;
      });
      if (this.permissionDialogs.length > 0) {
        this.presentPermissionsDialog(this.permissionDialogs[0]);
      }
    };
    /** 
     * Since these calls are asyncronous, multiple dialogs may be requested at the same time. 
     * We only want to present one and trigger all callbacks based on one modal result
     */
    const existingDialog = find(this.permissionDialogs, { component: component });
    this.permissionDialogs.push(params);
    if (!existingDialog) {
      this.presentPermissionsDialog(params);
    } else {
      this.log('Existing dialog, not presenting.');
    }
  }

  presentPermissionsDialog(dialog) {
    throw 'Must override SNComponentManager.presentPermissionsDialog';
  }

  openModalComponent(component) {
    throw 'Must override SNComponentManager.presentPermissionsDialog';
  }

  registerHandler(handler) {
    this.handlers.push(handler);
  }

  deregisterHandler(identifier) {
    const handler = find(this.handlers, { identifier: identifier });
    if (!handler) {
      this.log('Attempting to deregister non-existing handler');
      return;
    }
    this.handlers.splice(this.handlers.indexOf(handler), 1);
  }

  /** Called by other views when the iframe is ready */
  async registerComponentWindow(component, componentWindow) {
    if (component.window === componentWindow) {
      this.log('Web|componentManager', 'attempting to re-register same component window.');
    }
    this.log('Web|componentManager|registerComponentWindow', component);
    component.window = componentWindow;
    component.sessionKey = await Uuid.GenerateUuid();
    this.sendMessageToComponent(component, {
      action: ComponentActions.ComponentRegistered,
      sessionKey: component.sessionKey,
      componentData: component.componentData,
      data: {
        uuid: component.uuid,
        environment: environmentToString(this.environment),
        platform: platformToString(this.platform),
        activeThemeUrls: this.urlsForActiveThemes()
      }
    });
    this.postActiveThemesToComponent(component);
    if (this.desktopManager) {
      this.desktopManager.notifyComponentActivation(component);
    }
  }

  async activateComponent(component, dontSync = false) {
    const didChange = component.active !== true;
    component.active = true;
    for (const handler of this.handlers) {
      if (handler.areas.includes(component.area) || handler.areas.includes('*')) {
        handler.activationHandler &amp;&amp; handler.activationHandler(component);
      }
    }
    if (didChange &amp;&amp; !dontSync) {
      await this.modelManager.setItemDirty(component, true);
      this.syncService.sync();
    }
    if (!this.activeComponents.includes(component)) {
      this.activeComponents.push(component);
    }
    if (component.area === ComponentAreas.Themes) {
      this.postActiveThemesToAllComponents();
    }
  }

  async deactivateComponent(component, dontSync = false) {
    const didChange = component.active !== false;
    component.active = false;
    component.sessionKey = null;
    for (const handler of this.handlers) {
      if (handler.areas.includes(component.area) || handler.areas.includes('*')) {
        handler.activationHandler &amp;&amp; handler.activationHandler(component);
      }
    }
    if (didChange &amp;&amp; !dontSync) {
      await this.modelManager.setItemDirty(component, true);
      this.syncService.sync();
    }
    pull(this.activeComponents, component);
    this.streamObservers = this.streamObservers.filter((o) => {
      return o.component !== component;
    });
    this.contextStreamObservers = this.contextStreamObservers.filter((o) => {
      return o.component !== component;
    });
    if (component.area === ComponentAreas.Themes) {
      this.postActiveThemesToAllComponents();
    }
  }

  async reloadComponent(component) {
    /* Do soft deactivate */
    component.active = false;
    for (const handler of this.handlers) {
      if (handler.areas.includes(component.area) || handler.areas.includes('*')) {
        handler.activationHandler &amp;&amp; handler.activationHandler(component);
      }
    }
    this.streamObservers = this.streamObservers.filter((o) => {
      return o.component !== component;
    });
    this.contextStreamObservers = this.contextStreamObservers.filter((o) => {
      return o.component !== component;
    });
    if (component.area === ComponentAreas.Themes) {
      this.postActiveThemesToAllComponents();
    }
    /* Do soft activate */
    return new Promise((resolve, reject) => {
      this.timeout(() => {
        component.active = true;
        for (const handler of this.handlers) {
          if (handler.areas.includes(component.area) || handler.areas.includes('*')) {
            handler.activationHandler &amp;&amp; handler.activationHandler(component);
            resolve();
          }
        }
        if (!this.activeComponents.includes(component)) {
          this.activeComponents.push(component);
        }
        if (component.area === ComponentAreas.Themes) {
          this.postActiveThemesToAllComponents();
        }
        /* Resolve again in case first resolve in for loop isn't reached.
          Should be no effect if resolved twice, only first will be used. */
        resolve();
      });
    });
  }

  async deleteComponent(component) {
    await this.modelManager.setItemToBeDeleted(component);
    this.syncService.sync();
  }

  isComponentActive(component) {
    return component.active;
  }

  iframeForComponent(component) {
    for (const frame of Array.from(document.getElementsByTagName('iframe'))) {
      const componentId = frame.dataset.componentId;
      if (componentId === component.uuid) {
        return frame;
      }
    }
  }

  focusChangedForComponent(component) {
    const focused = document.activeElement === this.iframeForComponent(component);
    for (const handler of this.handlers) {
      /* Notify all handlers, and not just ones that match this component type */
      handler.focusHandler &amp;&amp; handler.focusHandler(component, focused);
    }
  }

  handleSetSizeEvent(component, data) {
    const setSize = (element, size) => {
      const widthString = isString(size.width) ? size.width : `${data.width}px`;
      const heightString = isString(size.height) ? size.height : `${data.height}px`;
      if (element) {
        element.setAttribute('style', `width:${widthString}; height:${heightString};`);
      }
    };
    if (component.area === ComponentAreas.Rooms || component.area === ComponentAreas.Modal) {
      const selector = component.area === ComponentAreas.Rooms ? 'inner' : 'outer';
      const content = document.getElementById(`component-content-${selector}-${component.uuid}`);
      if (content) {
        setSize(content, data);
      }
    } else {
      const iframe = this.iframeForComponent(component);
      if (!iframe) {
        return;
      }
      setSize(iframe, data);
      /** 
       * On Firefox, resizing a component iframe does not seem to have an effect with 
       * editor-stack extensions. Sizing the parent does the trick, however, we can't do 
       * this globally, otherwise, areas like the note-tags will not be able to expand 
       * outside of the bounds (to display autocomplete, for example).
       */
      if (component.area === ComponentAreas.EditorStack) {
        const parent = iframe.parentElement;
        if (parent) {
          setSize(parent, data);
        }
      }
    }
  }

  editorForNote(note) {
    const editors = this.componentsForArea(ComponentAreas.Editor);
    for (const editor of editors) {
      if (editor.isExplicitlyEnabledForItem(note)) {
        return editor;
      }
    }
    /* No editor found for note. Use default editor, if note does not prefer system editor */
    if (this.isMobile) {
      if (!note.content.mobilePrefersPlainEditor) {
        return this.getDefaultEditor();
      }
    } else {
      if (!note.getAppDataItem('prefersPlainEditor')) {
        return editors.filter((e) => { return e.isDefaultEditor(); })[0];
      }
    }
  }

  permissionsStringForPermissions(permissions, component) {
    let finalString = '';
    const permissionsCount = permissions.length;
    const addSeparator = (index, length) => {
      if (index > 0) {
        if (index === length - 1) {
          if (length === 2) {
            return ' and ';
          } else {
            return ', and ';
          }
        } else {
          return ', ';
        }
      }
      return '';
    };
    permissions.forEach((permission, index) => {
      if (permission.name === ComponentActions.StreamItems) {
        const types = permission.content_types.map((type) => {
          const desc = displayStringForContentType(type);
          if (desc) {
            return desc + 's';
          } else {
            return 'items of type ' + type;
          }
        });
        let typesString = '';
        for (let i = 0; i &lt; types.length; i++) {
          const type = types[i];
          typesString += addSeparator(i, types.length + permissionsCount - index - 1);
          typesString += type;
        }
        finalString += addSeparator(index, permissionsCount);
        finalString += typesString;
        if (types.length >= 2 &amp;&amp; index &lt; permissionsCount - 1) {
          /* If you have a list of types, and still an additional root-level 
             permission coming up, add a comma */
          finalString += ', ';
        }
      } else if (permission.name === ComponentActions.StreamContextItem) {
        const mapping = {
          [ComponentAreas.EditorStack]: 'working note',
          [ComponentAreas.NoteTags]: 'working note',
          [ComponentAreas.Editor]: 'working note'
        };

        finalString += addSeparator(index, permissionsCount, true);
        finalString += mapping[component.area];
      }
    });
    return finalString + '.';
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Fri Feb 28 2020 14:33:50 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
