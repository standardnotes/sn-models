<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>services/model_manager.js - SNJS Documentation</title>
    
    
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AccountSyncOperation.html">AccountSyncOperation</a></li><li><a href="AccountSyncResponseResolver.html">AccountSyncResponseResolver</a></li><li><a href="DeviceInterface.html">DeviceInterface</a></li><li><a href="HistorySession.html">HistorySession</a></li><li><a href="ItemsKeyManager.html">ItemsKeyManager</a><ul class='methods'><li data-type='method'><a href="ItemsKeyManager.html#addItemsKeyChangeObserver">addItemsKeyChangeObserver</a></li><li data-type='method'><a href="ItemsKeyManager.html#createNewDefaultItemsKey">createNewDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#defaultItemsKeyForItemVersion">defaultItemsKeyForItemVersion</a></li><li data-type='method'><a href="ItemsKeyManager.html#getDefaultItemsKey">getDefaultItemsKey</a></li><li data-type='method'><a href="ItemsKeyManager.html#handleDownloadFirstSyncCompletion">handleDownloadFirstSyncCompletion</a></li><li data-type='method'><a href="ItemsKeyManager.html#reencryptItemsKeys">reencryptItemsKeys</a></li><li data-type='method'><a href="ItemsKeyManager.html#setKeyManager">setKeyManager</a></li></ul></li><li><a href="OfflineSyncOperation_OfflineSyncOperation.html">OfflineSyncOperation</a></li><li><a href="PayloadCollection.html">PayloadCollection</a></li><li><a href="PayloadCollectionSet_PayloadCollectionSet.html">PayloadCollectionSet</a></li><li><a href="PayloadsDelta.html">PayloadsDelta</a></li><li><a href="PurePayload.html">PurePayload</a></li><li><a href="SFItem.html">SFItem</a><ul class='methods'><li data-type='method'><a href="SFItem.html#appDatacontentKeysToIgnoreWhenCheckingEquality">appDatacontentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SFItem.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SFItem.html#contentKeysToIgnoreWhenCheckingEquality">contentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SFItem.html#createdAtString">createdAtString</a></li><li data-type='method'><a href="SFItem.html#initUUID">initUUID</a></li><li data-type='method'><a href="SFItem.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SFItem.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SFItem.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SFItem.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNActionsService.html">SNActionsService</a><ul class='methods'><li data-type='method'><a href="SNActionsService.html#loadExtensionInContextOfItem">loadExtensionInContextOfItem</a></li></ul></li><li><a href="SNAlertService.html">SNAlertService</a></li><li><a href="SNApplication.html">SNApplication</a><ul class='methods'><li data-type='method'><a href="SNApplication.html#addEventObserver">addEventObserver</a></li><li data-type='method'><a href="SNApplication.html#addSingleEventObserver">addSingleEventObserver</a></li><li data-type='method'><a href="SNApplication.html#changeDeviceInterface">changeDeviceInterface</a></li><li data-type='method'><a href="SNApplication.html#changePasscode">changePasscode</a></li><li data-type='method'><a href="SNApplication.html#changePassword">changePassword</a></li><li data-type='method'><a href="SNApplication.html#clearDatabase">clearDatabase</a></li><li data-type='method'><a href="SNApplication.html#createItem">createItem</a></li><li data-type='method'><a href="SNApplication.html#deinit">deinit</a></li><li data-type='method'><a href="SNApplication.html#deleteItem">deleteItem</a></li><li data-type='method'><a href="SNApplication.html#deleteItemLocally">deleteItemLocally</a></li><li data-type='method'><a href="SNApplication.html#emptyTrash">emptyTrash</a></li><li data-type='method'><a href="SNApplication.html#findItem">findItem</a></li><li data-type='method'><a href="SNApplication.html#findItems">findItems</a></li><li data-type='method'><a href="SNApplication.html#findOrCreateTag">findOrCreateTag</a></li><li data-type='method'><a href="SNApplication.html#findTag">findTag</a></li><li data-type='method'><a href="SNApplication.html#generateUuid">generateUuid</a></li><li data-type='method'><a href="SNApplication.html#getDisplayableItems">getDisplayableItems</a></li><li data-type='method'><a href="SNApplication.html#getHost">getHost</a></li><li data-type='method'><a href="SNApplication.html#getItems">getItems</a></li><li data-type='method'><a href="SNApplication.html#getNoteCount">getNoteCount</a></li><li data-type='method'><a href="SNApplication.html#getNotesMatchingSmartTag">getNotesMatchingSmartTag</a></li><li data-type='method'><a href="SNApplication.html#getSmartTags">getSmartTags</a></li><li data-type='method'><a href="SNApplication.html#getSyncStatus">getSyncStatus</a></li><li data-type='method'><a href="SNApplication.html#getTrashedItems">getTrashedItems</a></li><li data-type='method'><a href="SNApplication.html#getUser">getUser</a></li><li data-type='method'><a href="SNApplication.html#getUserVersion">getUserVersion</a></li><li data-type='method'><a href="SNApplication.html#getValue">getValue</a></li><li data-type='method'><a href="SNApplication.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNApplication.html#importData">importData</a></li><li data-type='method'><a href="SNApplication.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNApplication.html#isEphemeralSession">isEphemeralSession</a></li><li data-type='method'><a href="SNApplication.html#isLocked">isLocked</a></li><li data-type='method'><a href="SNApplication.html#isStarted">isStarted</a></li><li data-type='method'><a href="SNApplication.html#launch">launch</a></li><li data-type='method'><a href="SNApplication.html#lock">lock</a></li><li data-type='method'><a href="SNApplication.html#mergeItem">mergeItem</a></li><li data-type='method'><a href="SNApplication.html#noAccount">noAccount</a></li><li data-type='method'><a href="SNApplication.html#prepareForLaunch">prepareForLaunch</a></li><li data-type='method'><a href="SNApplication.html#register">register</a></li><li data-type='method'><a href="SNApplication.html#registerService">registerService</a></li><li data-type='method'><a href="SNApplication.html#removePasscode">removePasscode</a></li><li data-type='method'><a href="SNApplication.html#removeValue">removeValue</a></li><li data-type='method'><a href="SNApplication.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNApplication.html#restart">restart</a></li><li data-type='method'><a href="SNApplication.html#saveItem">saveItem</a></li><li data-type='method'><a href="SNApplication.html#saveItems">saveItems</a></li><li data-type='method'><a href="SNApplication.html#savePayload">savePayload</a></li><li data-type='method'><a href="SNApplication.html#setHost">setHost</a></li><li data-type='method'><a href="SNApplication.html#setItemNeedsSync">setItemNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setItemsNeedsSync">setItemsNeedsSync</a></li><li data-type='method'><a href="SNApplication.html#setPasscode">setPasscode</a></li><li data-type='method'><a href="SNApplication.html#setStorageEncryptionPolicy">setStorageEncryptionPolicy</a></li><li data-type='method'><a href="SNApplication.html#setValue">setValue</a></li><li data-type='method'><a href="SNApplication.html#signIn">signIn</a></li><li data-type='method'><a href="SNApplication.html#signOut">signOut</a></li><li data-type='method'><a href="SNApplication.html#streamItems">streamItems</a></li><li data-type='method'><a href="SNApplication.html#sync">sync</a></li><li data-type='method'><a href="SNApplication.html#validateAccountPassword">validateAccountPassword</a></li></ul></li><li><a href="SNComponentManager.html">SNComponentManager</a><ul class='methods'><li data-type='method'><a href="SNComponentManager.html#deinit">deinit</a></li><li data-type='method'><a href="SNComponentManager.html#registerComponentWindow">registerComponentWindow</a></li></ul></li><li><a href="SNEditor.html">SNEditor</a></li><li><a href="SNHistoryManager.html">SNHistoryManager</a></li><li><a href="SNHttpService.html">SNHttpService</a></li><li><a href="SNKeyManager.html">SNKeyManager</a><ul class='methods'><li data-type='method'><a href="SNKeyManager.html#clearLocalKeyState">clearLocalKeyState</a></li><li data-type='method'><a href="SNKeyManager.html#contentTypeUsesRootKeyEncryption">contentTypeUsesRootKeyEncryption</a></li><li data-type='method'><a href="SNKeyManager.html#getAccountKeyParams">getAccountKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKey">getRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyParams">getRootKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#getRootKeyWrapperKeyParams">getRootKeyWrapperKeyParams</a></li><li data-type='method'><a href="SNKeyManager.html#hasPasscode">hasPasscode</a></li><li data-type='method'><a href="SNKeyManager.html#hasRootKeyWrapper">hasRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForDecryptionOfPayload">keyToUseForDecryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#keyToUseForEncryptionOfPayload">keyToUseForEncryptionOfPayload</a></li><li data-type='method'><a href="SNKeyManager.html#onStatusChange">onStatusChange</a></li><li data-type='method'><a href="SNKeyManager.html#removeRootKeyWrapper">removeRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#rootKeyNeedsUnwrapping">rootKeyNeedsUnwrapping</a></li><li data-type='method'><a href="SNKeyManager.html#setDeviceInterface">setDeviceInterface</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKey">setNewRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#setNewRootKeyWrapper">setNewRootKeyWrapper</a></li><li data-type='method'><a href="SNKeyManager.html#unwrapRootKey">unwrapRootKey</a></li><li data-type='method'><a href="SNKeyManager.html#validateAccountPassword">validateAccountPassword</a></li><li data-type='method'><a href="SNKeyManager.html#validatePasscode">validatePasscode</a></li><li data-type='method'><a href="SNKeyManager.html#validateWrappingKey">validateWrappingKey</a></li></ul></li><li><a href="SNMaxItemPayload.html">SNMaxItemPayload</a></li><li><a href="SNMigrationService.html">SNMigrationService</a><ul class='methods'><li data-type='method'><a href="SNMigrationService.html#handleApplicationStage">handleApplicationStage</a></li></ul></li><li><a href="SNModelManager.html">SNModelManager</a><ul class='methods'><li data-type='method'><a href="SNModelManager.html#addItem">addItem</a></li><li data-type='method'><a href="SNModelManager.html#createItem">createItem</a></li><li data-type='method'><a href="SNModelManager.html#getMasterCollection">getMasterCollection</a></li><li data-type='method'><a href="SNModelManager.html#insertItem">insertItem</a></li><li data-type='method'><a href="SNModelManager.html#insertItems">insertItems</a></li><li data-type='method'><a href="SNModelManager.html#setItemDirty">setItemDirty</a></li><li data-type='method'><a href="SNModelManager.html#setItemProperties">setItemProperties</a></li></ul></li><li><a href="SNNote.html">SNNote</a><ul class='methods'><li data-type='method'><a href="SNNote.html#appDatacontentKeysToIgnoreWhenCheckingEquality">appDatacontentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SNNote.html#collapseContent">collapseContent</a></li><li data-type='method'><a href="SNNote.html#contentKeysToIgnoreWhenCheckingEquality">contentKeysToIgnoreWhenCheckingEquality</a></li><li data-type='method'><a href="SNNote.html#createdAtString">createdAtString</a></li><li data-type='method'><a href="SNNote.html#initUUID">initUUID</a></li><li data-type='method'><a href="SNNote.html#populateDefaultContentValues">populateDefaultContentValues</a></li><li data-type='method'><a href="SNNote.html#setIsBeingReferencedBy">setIsBeingReferencedBy</a></li><li data-type='method'><a href="SNNote.html#strategyWhenConflictingWithItem">strategyWhenConflictingWithItem</a></li><li data-type='method'><a href="SNNote.html#updateLocalRelationships">updateLocalRelationships</a></li></ul></li><li><a href="SNNoteSFItem.html">SFItem</a></li><li><a href="SNNoteSNNoteSFItem.html">SFItem</a></li><li><a href="SNPrivilegesService.html">SNPrivilegesService</a><ul class='methods'><li data-type='method'><a href="SNPrivilegesService.html#actionRequiresPrivilege">actionRequiresPrivilege</a></li><li data-type='method'><a href="SNPrivilegesService.html#netCredentialsForAction">netCredentialsForAction</a></li></ul></li><li><a href="SNProtocolOperator.html">SNProtocolOperator</a><ul class='methods'><li data-type='method'><a href="SNProtocolOperator.html#createItemsKey">createItemsKey</a></li><li data-type='method'><a href="SNProtocolOperator.html#generateNewItemsKeyContent">generateNewItemsKeyContent</a></li></ul></li><li><a href="SNProtocolService.html">SNProtocolService</a><ul class='methods'><li data-type='method'><a href="SNProtocolService.html#compareRootKeys">compareRootKeys</a></li><li data-type='method'><a href="SNProtocolService.html#createBackupFile">createBackupFile</a></li><li data-type='method'><a href="SNProtocolService.html#decryptErroredItems">decryptErroredItems</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByDecryptingPayload">payloadByDecryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#payloadByEncryptingPayload">payloadByEncryptingPayload</a></li><li data-type='method'><a href="SNProtocolService.html#setKeyManager">setKeyManager</a></li><li data-type='method'><a href="SNProtocolService.html#supportedVersions">supportedVersions</a></li></ul></li><li><a href="SNRootKey.html">SNRootKey</a><ul class='methods'><li data-type='method'><a href="SNRootKey.html#compare">compare</a></li><li data-type='method'><a href="SNRootKey.html#getPersistableValue">getPersistableValue</a></li></ul></li><li><a href="SNRootKeyParams.html">SNRootKeyParams</a><ul class='methods'><li data-type='method'><a href="SNRootKeyParams.html#getPortableValue">getPortableValue</a></li></ul></li><li><a href="SNSavedServerItemPayload.html">SNSavedServerItemPayload</a></li><li><a href="SNSessionManager.html">SNSessionManager</a></li><li><a href="SNSingletonManager.html">SNSingletonManager</a><ul class='methods'><li data-type='method'><a href="SNSingletonManager.html#addObservers">addObservers</a></li><li data-type='method'><a href="SNSingletonManager.html#registerPredicate">registerPredicate</a></li></ul></li><li><a href="SNStorageService.html">SNStorageService</a><ul class='methods'><li data-type='method'><a href="SNStorageService.html#canDecryptWithKey">canDecryptWithKey</a></li><li data-type='method'><a href="SNStorageService.html#clearValues">clearValues</a></li><li data-type='method'><a href="SNStorageService.html#decryptStorage">decryptStorage</a></li><li data-type='method'><a href="SNStorageService.html#generatePersistenceValue">generatePersistenceValue</a></li><li data-type='method'><a href="SNStorageService.html#getAllRawPayloads">getAllRawPayloads</a></li><li data-type='method'><a href="SNStorageService.html#getPersistenceKey">getPersistenceKey</a></li><li data-type='method'><a href="SNStorageService.html#handleApplicationStage">handleApplicationStage</a></li><li data-type='method'><a href="SNStorageService.html#isStorageWrapped">isStorageWrapped</a></li><li data-type='method'><a href="SNStorageService.html#setInitialValues">setInitialValues</a></li></ul></li><li><a href="SNSyncService.html">SNSyncService</a><ul class='methods'><li data-type='method'><a href="SNSyncService.html#computeDataIntegrityHash">computeDataIntegrityHash</a></li><li data-type='method'><a href="SNSyncService.html#getDatabasePayloads">getDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#handleNeverSyncedDeleted">handleNeverSyncedDeleted</a></li><li data-type='method'><a href="SNSyncService.html#isDatabaseLoaded">isDatabaseLoaded</a></li><li data-type='method'><a href="SNSyncService.html#loadDatabasePayloads">loadDatabasePayloads</a></li><li data-type='method'><a href="SNSyncService.html#markAllItemsAsNeedingSync">markAllItemsAsNeedingSync</a></li><li data-type='method'><a href="SNSyncService.html#payloadsByPreparingForServer">payloadsByPreparingForServer</a></li><li data-type='method'><a href="SNSyncService.html#popPayloadsNeedingPreSyncSave">popPayloadsNeedingPreSyncSave</a></li><li data-type='method'><a href="SNSyncService.html#popSpawnQueue">popSpawnQueue</a></li><li data-type='method'><a href="SNSyncService.html#repersistAllItems">repersistAllItems</a></li><li data-type='method'><a href="SNSyncService.html#resetSyncState">resetSyncState</a></li><li data-type='method'><a href="SNSyncService.html#resolveOutOfSync">resolveOutOfSync</a></li><li data-type='method'><a href="SNSyncService.html#sync">sync</a></li><li data-type='method'><a href="SNSyncService.html#ut_beginLatencySimulator">ut_beginLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_endLatencySimulator">ut_endLatencySimulator</a></li><li data-type='method'><a href="SNSyncService.html#ut_setDatabaseLoaded">ut_setDatabaseLoaded</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#arrayByDifference">arrayByDifference</a></li><li><a href="global.html#arrayByRemovingFromIndex">arrayByRemovingFromIndex</a></li><li><a href="global.html#compareVersions">compareVersions</a></li><li><a href="global.html#deepMerge">deepMerge</a></li><li><a href="global.html#DEFAULT_AUTO_SYNC_INTERVAL">DEFAULT_AUTO_SYNC_INTERVAL</a></li><li><a href="global.html#DEFAULT_ITEM_REVISIONS_THRESHOLD">DEFAULT_ITEM_REVISIONS_THRESHOLD</a></li><li><a href="global.html#extendArray">extendArray</a></li><li><a href="global.html#intentRequiresEncryption">intentRequiresEncryption</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_NONE">KEY_MODE_ROOT_KEY_NONE</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_ONLY">KEY_MODE_ROOT_KEY_ONLY</a></li><li><a href="global.html#KEY_MODE_ROOT_KEY_PLUS_WRAPPER">KEY_MODE_ROOT_KEY_PLUS_WRAPPER</a></li><li><a href="global.html#KEY_MODE_WRAPPER_ONLY">KEY_MODE_WRAPPER_ONLY</a></li><li><a href="global.html#LARGE_ENTRY_DELTA_THRESHOLD">LARGE_ENTRY_DELTA_THRESHOLD</a></li><li><a href="global.html#LAST_NONROOT_ITEMS_KEY_VERSION">LAST_NONROOT_ITEMS_KEY_VERSION</a></li><li><a href="global.html#lastElement">lastElement</a></li><li><a href="global.html#omitByCopy">omitByCopy</a></li><li><a href="global.html#PayloadsByAlternatingUuid">PayloadsByAlternatingUuid</a></li><li><a href="global.html#PayloadsByDuplicating">PayloadsByDuplicating</a></li><li><a href="global.html#pickByCopy">pickByCopy</a></li><li><a href="global.html#RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP">RAW_STORAGE_KEY_LAST_MIGRATION_TIMESTAMP</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#removeFromIndex">removeFromIndex</a></li><li><a href="global.html#SortPayloadsByRecentAndContentPriority">SortPayloadsByRecentAndContentPriority</a></li><li><a href="global.html#StorageEncryptionPolicies">StorageEncryptionPolicies</a></li><li><a href="global.html#StoragePersistencePolicies">StoragePersistencePolicies</a></li><li><a href="global.html#StorageValueModes">StorageValueModes</a></li><li><a href="global.html#subtractFromArray">subtractFromArray</a></li><li><a href="global.html#ValueModesKeys">ValueModesKeys</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">services/model_manager.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import remove from 'lodash/remove';
import pull from 'lodash/pull';
import sortedIndexBy from 'lodash/sortedIndexBy';
import { findInArray } from '@Lib/utils';
import {
  ContentTypes,
  CreateItemFromPayload,
  SFPredicate,
  SNSmartTag
} from '@Models';
import { PureService } from '@Lib/services/pure_service';
import {
  PayloadSources,
  PayloadsByDuplicating,
  CreateMaxPayloadFromAnyObject,
  PayloadCollection,
  DeltaFileImport
} from '@Payloads';
import { Uuid } from '@Lib/uuid';

/**
 * The model manager is responsible for keeping state regarding what items exist in the
 * global application state. It does so by exposing functions that allow consumers to 'map'
 * a detached payload into global application state. Whenever a change is made or retrieved
 * from any source, it must be mapped in order to be properly reflected in global application state.
 * The model manager deals only with in-memory state, and does not deal directly with storage.
 * It also serves as a query store, and can be queried for current notes, tags, etc.
 * It exposes methods that allow consumers to listen to mapping events. This is how
 * applications 'stream' items to display in the interface.
 */
export class SNModelManager extends PureService {
  constructor({ timeout }) {
    super();
    this.timeout = timeout;
    this.mappingObservers = [];
    this.creationObservers = [];
    this.items = [];
    this.itemsKeys = [];
    this.notes = [];
    this.tags = [];
    this.components = [];
    this.itemsHash = {};
    this.resolveQueue = {};
    this.masterCollection = new PayloadCollection();
    this.buildSystemSmartTags();
  }

  /**
  * Our payload collectionn keeps the latest mapped payload for every payload
  * that passes through our mapping function. Use this to query current state
  * as needed to make decisions, like about duplication or uuid alteration.
  */
  getMasterCollection() {
    return this.masterCollection;
  }

  deinit() {
    super.deinit();
    this.resetState();
  }

  resetState() {
    this.items.length = 0;
    this.itemsKeys.length = 0;
    this.notes.length = 0;
    this.tags.length = 0;
    this.components.length = 0;
    this.itemsHash = {};
    this.resolveQueue = {};
    this.masterCollection = new PayloadCollection();
  }

  /**
   * Consumers wanting to modify an item should run it through this block,
   * so that data is properly mapped through our function, and latest state
   * is properly reconciled.
   */
  async setItemProperties({ item, properties }) {
    return this.setItemsProperties({ items: [item], properties });
  }

  async setItemsProperties({ items, properties }) {
    const keys = Object.keys(properties);
    for (const item of items) {
      for (const key of keys) {
        item[key] = properties[key];
      }
    }
    await this.mapItems({ items });
  }

  async modifyItem({ item, modifier }) {
    return this.modifyItems({ items: [item], modifier });
  }

  async modifyItems({ items, modifier }) {
    await modifier();
    await this.setItemsDirty(items, true);
  }

  async mapCollectionToLocalItems({ collection, sourceKey }) {
    return this.mapPayloadsToLocalItems({
      payloads: collection.allPayloads,
      source: collection.source,
      sourceKey: sourceKey
    });
  }

  async mapItem({ item, source, sourceKey }) {
    const items = await this.mapItems({
      items: [item],
      source,
      sourceKey
    });
    return items[0];
  }

  async mapItems({ items, source, sourceKey }) {
    const payloads = items.map((item) => item.payloadRepresentation());
    return this.mapPayloadsToLocalItems({
      payloads: payloads,
      source: source,
      sourceKey: sourceKey
    });
  }

  async mapPayloadToLocalItem({ payload }) {
    const items = await this.mapPayloadsToLocalItems({
      payloads: [payload]
    });
    return items[0];
  }

  async mapPayloadsToLocalItems({ payloads, source, sourceKey }) {
    const itemsToNotifyObserversOf = [];
    const newItems = [];
    const processed = {};

    /** First loop should process payloads and add items only; no relationship handling. */
    for (const payload of payloads) {
      if (!payload) {
        console.error('Payload is null');
        continue;
      }

      if (!payload.isPayload) {
        throw 'Attempting to map non-payload object into local model.';
      }

      const isCorrupt = !payload.content_type || !payload.uuid;
      if (isCorrupt &amp;&amp; !payload.deleted) {
        console.error('Payload is corrupt:', payload);
        continue;
      }

      let item = this.findItem(payload.uuid);

      let isDirtyDeleted = false;
      if (payload.deleted === true) {
        if (payload.dirty) {
          /**
           * Item was marked as deleted but not yet synced (in offline scenario).
           * Create this item as usual, but do not add it to individual arrays,
           * and remove from individual arrays if neccesary. i.e add to this.items
           * but not this.notes (so that it can be retrieved with getDirtyItems)
           */
          isDirtyDeleted = true;
          if (item) {
            this.removeItemFromRespectiveArray(item);
            item.updateLocalRelationships();
          }
        } else {
          if (item) {
            await this.removeItemLocally(item);
          } else {
            /** Item doesn't exist locally, don't create it. */
            continue;
          }
        }
      }

      if (item) {
        item.updateFromPayload(payload);
      } else {
        item = CreateItemFromPayload(payload);
        this.insertItems({
          items: [item],
          globalOnly: isDirtyDeleted
        });
        newItems.push(item);
      }

      /** Observers do not need to handle items that errored while decrypting. */
      if (!item.errorDecrypting) {
        itemsToNotifyObserversOf.push(item);
      }

      processed[item.uuid] = {
        item: item,
        payload: payload
      };
    }

    /** Second loop should process references */
    const allPayloads = [];
    const allItems = [];
    for (const uuid of Object.keys(processed)) {
      const { item, payload } = processed[uuid];
      allPayloads.push(payload);
      allItems.push(item);
      if (payload.content) {
        await this.resolveReferencesForItem(item);
      }

      const interestedItems = this.popItemsInterestedInMissingItem({
        item: item
      });
      for (const interestedItem of interestedItems) {
        interestedItem.addItemAsRelationship(item);
      }

      item.didCompleteMapping(source);
    }

    const newCollection = new PayloadCollection({
      payloads: allItems.map((item) => item.payloadRepresentation()),
      source: source
    });
    this.masterCollection = this.masterCollection.concat(newCollection);

    if(newItems.length > 0) {
      await this.notifyCreationObservers(
        newItems,
        source,
        sourceKey
      );
    }
    await this.notifyMappingObservers(
      itemsToNotifyObserversOf,
      source,
      sourceKey
    );
    return allItems;
  }

  /** @access public */
  insertItem({ item }) {
    this.insertItems({ items: [item] });
  }

  /** @access public */
  insertItems({ items, globalOnly }) {
    for (const item of items) {
      if (this.itemsHash[item.uuid]) {
        continue;
      }
      this.itemsHash[item.uuid] = item;
      this.items.push(item);
      /**
       * In some cases, you just want to add the item to this.items, and not to
       * the individual arrays This applies when you want to keep an item
       * syncable, but not display it via the individual arrays
       */
      if (globalOnly) {
        continue;
      }
      if (item.content_type === ContentTypes.ItemsKey) {
        this.itemsKeys.unshift(item);
      }
      else if (item.content_type === ContentTypes.Tag) {
        const index = sortedIndexBy(this.tags, item, function (item) {
          if (item.title) { return item.title.toLowerCase(); }
          else { return ''; }
        });
        this.tags.splice(index, 0, item);
      }
      else if (item.content_type === ContentTypes.Note) {
        this.notes.unshift(item);
      }
      else if (item.content_type === ContentTypes.Component) {
        this.components.unshift(item);
      }
    }
  }

  resolveRelationshipWhenItemAvailable({ interestedItem, missingItemId }) {
    const interestedItems = this.resolveQueue[missingItemId] || [];
    interestedItems.push(interestedItem);
    this.resolveQueue[missingItemId] = interestedItems;
  }

  popItemsInterestedInMissingItem({ item }) {
    const interestedItems = this.resolveQueue[item.uuid];
    delete this.resolveQueue[item.uuid];
    return interestedItems || [];
  }

  async resolveReferencesForItem(item, markReferencesDirty = false) {
    if (item.errorDecrypting) {
      return;
    }

    const content = item.content;
    /**
     * If another client removes an item's references, this client won't pick
     * up the removal unless we remove everything not present in the current
     * list of references
     */
    item.updateLocalRelationships();
    if (!content.references || item.deleted) {
      return;
    }
    /** Make copy, references will be modified in array */
    const references = content.references.slice();
    const referencesIds = references.map((ref) => { return ref.uuid; });
    const includeBlanks = true;
    const items = this.findItems(referencesIds, includeBlanks);

    for (const [index, referencedItem] of items.entries()) {
      if (referencedItem) {
        item.addItemAsRelationship(referencedItem);
        if (markReferencesDirty) {
          await this.setItemDirty(referencedItem, true);
        }
      } else {
        const referenceId = referencesIds[index];
        this.resolveRelationshipWhenItemAvailable({
          interestedItem: item,
          missingItemId: referenceId
        });
      }
    }
  }


  /**
   * @observers
   */

  /* Notifies observers when an item has been created */
  addCreationObserver(observer) {
    this.creationObservers.push(observer);
    return observer;
  }

  removeCreationObserver(observer) {
    remove(this.creationObservers, observer);
  }

  async notifyCreationObservers(items, source, sourceKey) {
    for (const observer of this.creationObservers) {
      await observer.callback({
        items: items,
        source: source,
        sourceKey: sourceKey
      });
    }
  }

  /* Notifies observers when an item has been mapped from */
  addMappingObserver(types, callback) {
    return this.addMappingObserverWithPriority({ types, callback, priority: 1 });
  }

  addMappingObserverWithPriority({ priority, types, callback }) {
    if (!Array.isArray(types)) {
      types = [types];
    }
    const observer = { types, priority, callback };
    this.mappingObservers.push(observer);
    return () => {
      pull(this.mappingObservers, observer);
    };
  }

  /* Note that this function is public, and can also be called manually (desktopManager uses it) */
  async notifyMappingObservers(items, source, sourceKey) {
    const observers = this.mappingObservers.sort((a, b) => {
      return a.priority &lt; b.priority ? -1 : 1;
    });
    for (const observer of observers) {
      const allRelevantItems = observer.types.includes('*')
        ? items
        : items.filter((item) => {
          return observer.types.includes(item.content_type);
        });
      const validItems = [];
      const deletedItems = [];
      for (const item of allRelevantItems) {
        if (item.deleted) {
          deletedItems.push(item);
        } else {
          validItems.push(item);
        }
      }

      if (allRelevantItems.length > 0) {
        await this._callMappingObserver(
          observer,
          allRelevantItems,
          validItems,
          deletedItems,
          source,
          sourceKey
        );
      }
    }
  }

  async _callMappingObserver(
    observer,
    allRelevantItems,
    validItems,
    deletedItems,
    source,
    sourceKey
  ) {
    return new Promise((resolve, reject) => {
      this.timeout(async () => {
        try {
          await observer.callback(
            allRelevantItems,
            validItems,
            deletedItems,
            source,
            sourceKey
          );
        } catch (e) {
          console.error('Mapping observer exception', e);
        } finally {
          resolve();
        }
      });
    });
  }

  /**
   * When a client sets an item as dirty, it means its values has changed,
   * and everyone should know about it. Particularly extensions. For example,
   * if you edit the title of a note, extensions won't be notified until
   * the save sync completes. With this, they'll be notified immediately.
   */
  async setItemDirty(item, dirty = true, updateClientDate, source, sourceKey) {
    return this.setItemsDirty([item], dirty, updateClientDate, source, sourceKey);
  }

  async setItemsDirty(items, dirty = true, updateClientDate, source, sourceKey) {
    for (const item of items) {
      if (!item.isItem) {
        throw 'Attempting to dirty non-item object.';
      }
      item.setDirty({ dirty, updateClientDate, authorized: true });
    }
    return this.mapItems({
      items: items,
      source: source || PayloadSources.LocalDirtied,
      sourceKey: sourceKey
    });
  }

  async duplicateItem({ item, isConflict }) {
    if (!item.isItem) {
      throw 'Attempting to duplicate non-item object.';
    }
    const payload = CreateMaxPayloadFromAnyObject({ object: item });
    const payloads = await PayloadsByDuplicating({
      payload: payload,
      baseCollection: this.getMasterCollection(),
      isConflict: isConflict,
    });
    const results = await this.mapPayloadsToLocalItems({
      payloads: payloads
    });
    const copy = results.find((p) => p.uuid === payloads[0].uuid);
    return copy;
  }

  /** @access public */
  async createItem({ contentType, content, add, needsSync }) {
    if (!contentType) {
      throw 'Attempting to create item with no contentType';
    }
    const payload = CreateMaxPayloadFromAnyObject({
      object: {
        uuid: await Uuid.GenerateUuid(),
        content_type: contentType,
        content: content
      }
    });
    const item = CreateItemFromPayload(payload);
    if (add) {
      this.insertItem({ item: item });
      if (needsSync) {
        await this.setItemDirty(item);
      }
      await this.notifyCreationObservers(
        [item]
      );
    }
    return item;
  }

  /**
   * Adds items to model management.
   * @param globalOnly  Whether the item should only be added to main .items
   *                    array, and not individual item arrays like .notes,
   *                    .tags, .components, etc.
   */
  async addItem(item, globalOnly = false) {
    return this.addItems([item], globalOnly);
  }

  async addItems(items, globalOnly = false) {
    console.warn('ModelManager.addItems is depracated. Use mapPayloadsToLocalItems instead.');
    const payloads = items.map((item) => CreateMaxPayloadFromAnyObject({ object: item }));
    await this.mapPayloadsToLocalItems({ payloads: payloads });
  }

  getDirtyItems() {
    return this.items.filter((item) => {
      // An item that has an error decrypting can be synced only if it is being deleted.
      // Otherwise, we don't want to send corrupt content up to the server.
      return item.dirty &amp;&amp; !item.dummy &amp;&amp; (!item.errorDecrypting || item.deleted);
    });
  }

  async clearDirtyItems(items) {
    return this.setItemsDirty(items, false);
  }

  /* Used when changing encryption key */
  async setAllItemsDirty() {
    const relevantItems = this.allItems;
    await this.setItemsDirty(relevantItems, true);
  }

  async setItemToBeDeleted(item) {
    item.deleted = true;
    if (!item.dummy) {
      await this.setItemDirty(item, true);
    }
    await this.handleReferencesForItemDeletion(item);
    this.removeItemFromRespectiveArray(item);
  }

  async handleReferencesForItemDeletion(item) {
    /** Handle direct relationships */
    if (!item.errorDecrypting) {
      for (const reference of item.content.references) {
        const relationship = this.findItem(reference.uuid);
        if (relationship) {
          item.removeItemAsRelationship(relationship);
          if (relationship.hasRelationshipWithItem(item)) {
            relationship.removeItemAsRelationship(item);
            await this.setItemDirty(relationship, true);
          }
        }
      }
    }

    /** Handle indirect relationships */
    const referencingItems = item.allReferencingItems;
    for (const referencingItem of referencingItems) {
      referencingItem.removeItemAsRelationship(item);
      await this.setItemDirty(referencingItem, true);
    }

    item.resetLocalReferencePointers();
  }

  async setItemsToBeDeleted(items) {
    for (const item of items) {
      await this.setItemToBeDeleted(item);
    }
  }

  async removeItemLocally(item) {
    remove(this.items, { uuid: item.uuid });
    delete this.itemsHash[item.uuid];
    this.removeItemFromRespectiveArray(item);
    item.isBeingRemovedLocally();
  }

  removeItemFromRespectiveArray(item) {
    if (item.content_type === ContentTypes.Tag) {
      remove(this.tags, { uuid: item.uuid });
    } else if (item.content_type === ContentTypes.Note) {
      remove(this.notes, { uuid: item.uuid });
    } else if (item.content_type === ContentTypes.Component) {
      remove(this.components, { uuid: item.uuid });
    } else if (item.content_type === ContentTypes.ItemsKey) {
      remove(this.itemsKeys, { uuid: item.uuid });
    }
  }

  /* Searching */

  get allItems() {
    return this.items.slice();
  }

  get allNondummyItems() {
    return this.items.filter((item) => {
      return !item.dummy;
    });
  }

  get nonDeletedItems() {
    return this.items.filter((item) => {
      return !item.dummy &amp;&amp; !item.deleted;
    });
  }

  getItems(contentType) {
    if (Array.isArray(contentType)) {
      return this.allItems.filter((item) => {
        return !item.dummy &amp;&amp; (
          contentType.includes(item.content_type) ||
          contentType.includes('*')
        );
      });
    }
    const managed = this.managedItemsForContentType(contentType);
    return managed || this.getItems([contentType]);
  }

  managedItemsForContentType(contentType) {
    if (contentType === ContentTypes.Note) {
      return this.notes;
    } else if (contentType === ContentTypes.Component) {
      return this.components;
    } else if (contentType === ContentTypes.Tag) {
      return this.tags;
    }

    return null;
  }

  invalidItems() {
    return this.allItems.filter((item) => {
      return item.errorDecrypting;
    });
  }

  validItemsForContentType(contentType) {
    const managed = this.managedItemsForContentType(contentType);
    const items = managed || this.allItems;
    return items.filter((item) => {
      return !item.errorDecrypting &amp;&amp; (
        Array.isArray(contentType)
          ? contentType.includes(item.content_type)
          : item.content_type === contentType
      );
    });
  }

  findItem(itemId) {
    return this.itemsHash[itemId];
  }

  findItems(ids, includeBlanks = false) {
    const results = [];
    for (const id of ids) {
      const item = this.itemsHash[id];
      if (item || includeBlanks) {
        results.push(item);
      }
    }
    return results;
  }

  itemsMatchingPredicate(predicate) {
    return this.itemsMatchingPredicates([predicate]);
  }

  itemsMatchingPredicates(predicates) {
    return this.filterItemsWithPredicates(this.allItems, predicates);
  }

  filterItemsWithPredicates(items, predicates) {
    const results = items.filter((item) => {
      if(item.deleted) {
        return false;
      }
      for (const predicate of predicates) {
        if (!item.satisfiesPredicate(predicate)) {
          return false;
        }
      }
      return true;
    });
    return results;
  }

  async importPayloads(payloads) {
    const delta = new DeltaFileImport({
      baseCollection: this.getMasterCollection(),
      applyCollection: new PayloadCollection({
        payloads: payloads,
        source: PayloadSources.FileImport
      })
    });
    const collection = await delta.resultingCollection();
    const items = await this.mapCollectionToLocalItems({
      collection: collection
    });
    for (const item of items) {
      await this.setItemDirty(item, true, false);
      item.deleted = false;
    }
    return items;
  }

  noteCount() {
    return this.notes.filter((n) => !n.dummy).length;
  }

  removeAllItemsFromMemory() {
    for (const item of this.items) {
      item.deleted = true;
    }
    this.notifyMappingObservers(this.items);
    this.resetState();
  }

  findTag({ title }) {
    return findInArray(this.tags, 'title', title);
  }

  async findOrCreateTag({ title }) {
    let tag = this.findTag({ title });
    if (!tag) {
      tag = await this.createItem({
        contentType: 'Tag',
        content: { title: title },
        add: true,
        needsSync: true
      });
    }
    return tag;
  }

  reorderTagLocation(tag) {
    pull(this.tags, tag);
    this.tags.splice(sortedIndexBy(this.tags, tag, (tag) => {
      if (tag.title) return tag.title.toLowerCase();
      else return '';
    }), 0, tag);
  }

  notesMatchingSmartTag(tag) {
    const contentTypePredicate = new SFPredicate('content_type', '=', 'Note');
    const predicates = [contentTypePredicate, tag.content.predicate];
    if (!tag.content.isTrashTag) {
      const notTrashedPredicate = new SFPredicate('content.trashed', '=', false);
      predicates.push(notTrashedPredicate);
    }
    const results = this.itemsMatchingPredicates(predicates);
    return results;
  }

  trashSmartTag() {
    return this.systemSmartTags.find((tag) => tag.content.isTrashTag);
  }

  trashedItems() {
    return this.notesMatchingSmartTag(this.trashSmartTag());
  }

  emptyTrash() {
    const notes = this.trashedItems();
    for (const note of notes) {
      this.setItemToBeDeleted(note);
    }
  }

  buildSystemSmartTags() {
    this.systemSmartTags = SNSmartTag.systemSmartTags();
  }

  getSmartTagWithId(id) {
    return this.getSmartTags().find((candidate) => candidate.uuid === id);
  }

  getSmartTags() {
    const userTags = this.validItemsForContentType(ContentTypes.SmartTag)
      .sort((a, b) => {
        return a.content.title &lt; b.content.title ? -1 : 1;
      });
    return this.systemSmartTags.concat(userTags);
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Fri Feb 28 2020 14:33:50 GMT-0600 (Central Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
